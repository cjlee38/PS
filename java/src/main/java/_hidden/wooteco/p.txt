문제 설명
정수 1, 2, 3을 담고 있는 배열이 주어집니다. 이 배열에 원소를 추가해서 배열 안의 1, 2, 3의 개수가 모두 같아지도록 하려 합니다. 단, 추가하는 원소의 개수는 최소가 되어야 합니다.

다음은 입출력 예제 1번의 배열을 나타낸 예시입니다.

[2, 1, 3, 1, 2, 1]
위 배열에 원소 2, 3, 3을 순서대로 추가하면 다음과 같이 바뀝니다.

[2, 1, 3, 1, 2, 1, 2, 3, 3]
원소 1, 2, 3의 개수가 모두 3개로 같아졌습니다. 세 개보다 적은 개수의 원소를 추가하여 1, 2, 3의 개수가 같도록 만드는 방법은 없으며, 추가해야 하는 원소는 1: 0개, 2: 1개, 3: 2개입니다.

정수 1, 2, 3을 담고 있는 배열 arr가 매개변수로 주어집니다. 원소 추가를 최소로 하여 배열 안의 1, 2, 3 각각의 개수가 모두 같도록 만들 때, 추가해야 하는 각 원소의 개수를 1, 2, 3 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.

제한사항
1 ≤ arr의 길이 ≤ 100,000
arr의 원소는 1 또는 2 또는 3입니다.
입출력 예
arr	result
[2, 1, 3, 1, 2, 1]	[0, 1, 2]
[3, 3, 3, 3, 3, 3]	[6, 6, 0]
[1, 2, 3]	[0, 0, 0]
입출력 예 설명
입출력 예 #1

문제 예시와 같습니다.

입출력 예 #2

원소 1을 6개, 원소 2를 6개 추가하면 각 원소의 개수를 6개로 같게 만들 수 있습니다. 이보다 더 적은 수의 원소를 추가해서 배열 안의 1, 2, 3의 개수가 같도록 만드는 방법은 없습니다. 따라서 [6, 6, 0]을 return 합니다.

입출력 예 #3

이미 1, 2, 3의 개수가 모두 1개로 같기 때문에 원소를 추가하지 않아도 됩니다. 따라서 [0, 0, 0]을 return 합니다.

-----


문제 설명
당신은 스마트폰 어플리케이션을 이용하여 공부한 시간을 기록하려합니다. 어플리케이션의 기능은 다음과 같습니다.

시작 버튼: 공부를 시작할 때의 시각을 기록합니다.
중지 버튼: 공부를 중지할 때의 시각을 기록합니다.
하지만, 어플리케이션에 기록된 시간에 항상 공부만 했다는 보장이 없기 때문에 다음과 같은 규칙을 적용해 실제로 공부한 시간을 구하려 합니다.

공부를 시작하고 5분이 지나기 전에 중지했다면 실제로 공부한 시간에 포함시키지 않습니다.
공부를 시작하고 1시간 45분이 넘어서 중지했다면 1시간 45분까지만 공부한 시간으로 인정합니다.
공부를 시작한 시각과 중지한 시각이 연속적으로 주어집니다. 처음 주어진 시각은 무조건 공부를 시작한 시각이며, 마지막 시각은 무조건 공부를 중지한 시각입니다. 차례대로 번갈아가면서 [시작 시각, 중지 시각, 시작 시각, 중지 시각, ..., 중지 시각] 형태로 주어집니다. 이때 실제로 공부한 시간을 구하려 합니다.

어플리케이션의 기록을 담은 문자열 배열 log가 매개변수로 주어졌을 때, 실제로 공부한 시간을 HH:MM 형태로 return 하도록 solution 함수를 완성해주세요.

HH:MM형태는 시:분을 뜻합니다. 이때 시혹은 분이 한 자리 수라면 왼쪽에 0을 채워 항상 두 자리가 되게 합니다.
제한사항
log의 길이는 짝수입니다.
2 ≤ log의 길이 ≤ 1,440
log의 원소는 시각을 나타내며 길이는 항상 5입니다.
시각은 항상 시:분을 뜻하는 HH:MM 형태로 주어집니다.
잘못된 시각은 주어지지 않습니다.
중복된 시각은 주어지지 않습니다.
시각은 오름차순으로 주어지며, 모두 같은 날 기록한 내용만 주어집니다.
입출력 예
log	result
["08:30", "09:00", "14:00", "16:00", "16:01", "16:06", "16:07", "16:11"]	"02:20"
["01:00", "08:00", "15:00", "15:04", "23:00", "23:59"]	"02:44"
입출력 예 설명
입출력 예 #1

어플리케이션의 기록을 가지고 공부한 시간을 나타내면 다음과 같습니다.

08:30 ~ 09:00, 14:00 ~ 16:00, 16:01 ~ 16:06, 16:07 ~ 16:11

규칙에 따라 실제로 공부한 시간을 구하는 과정은 다음과 같습니다.

공부한 시각(시작 ~ 끝)	공부한 시간(분)	실제로 공부한 시간(분)
08:30 ~ 09:00	30	30
14:00 ~ 16:00	120	105
16:01 ~ 16:06	5	5
16:07 ~ 16:11	4	0
따라서 실제로 공부한 시간은 30 + 105 + 5 + 0 = 140분이고, 140분은 2시간 20분이므로 "02:20"을 return 해야 합니다.

입출력 예 #2

공부한 시각(시작 ~ 끝)	공부한 시간(분)	실제로 공부한 시간(분)
01:00 ~ 08:00	420	105
15:00 ~ 15:04	4	0
23:00 ~ 23:59	59	59
따라서 실제로 공부한 시간은 105 + 0 + 59 = 164분이고, 164분은 2시간 44분이므로 "02:44"을 return 해야 합니다.

-----


문제 설명
음식점에서 하루 동안의 판매 수익을 계산하고자 합니다. 아래 3개의 표는 각각 음식점에서 사용하는 재료, 판매하는 메뉴, 하루 동안의 판매 실적에 대한 정보를 나타내는 예시입니다.

재료의 정보

재료 이름	가격(원)
r	10
a	23
t	124
k	9
음식점에서는 메뉴를 만들기 위해 재료를 구매해옵니다. 재료 r의 구매 비용은 10원, 재료 a의 구매 비용은 23원, 재료 t의 구매 비용은 124원, 재료 k의 구매 비용은 9원입니다.


메뉴의 정보

메뉴 이름	필요한 재료	판매가(원)
PIZZA	arraak	145
HAMBURGER	tkar	180
BREAD	kkk	30
ICECREAM	rar	50
SHAVEDICE	rar	45
JUICE	rra	55
WATER	a	20
필요한 재료에 포함된 알파벳의 개수는 해당 메뉴를 만들 때 필요한 재료의 수입니다.
음식점에서 PIZZA를 만들기 위해서 6개의 재료(a는 3개, r은 2개, k는 1개)가 필요하므로, 총 재료비는 69 + 20 + 9 = 98입니다.
a : 3개 → 23 x 3 = 69
r : 2개 → 10 x 2 = 20
k : 1개 → 9 x 1 = 9
PIZZA를 1개 판매하면 얻을 수 있는 수익은 다음과 같습니다.
145(판매가) - 98(재료비) = 47(수익)
ICECREAM, SHAVEDICE, JUICE는 모두 똑같은 재료(r은 2개, a는 1개)를 사용하므로 재료비는 같으나, 판매가가 다르므로 판매 시 얻을 수 있는 수익은 다릅니다.
WATER처럼 판매하면 수익이 아닌, 손실이 발생하는 메뉴도 있을 수 있습니다.
20(판매가) - 23(재료비) = -3


하루 동안의 판매 실적

메뉴 이름	판매 수량
BREAD	5
ICECREAM	100
PIZZA	7
JUICE	10
WATER	1
BREAD 5개를 판매해서 얻은 수익 : (30 - 27) x 5 = 15
ICECREAM 100개를 판매해서 얻은 수익 : (50 - 43) x 100 = 700
PIZZA 7개를 판매해서 얻은 수익 : (145 - 98) x 7 = 329
JUICE 10개를 판매해서 얻은 수익 : (55 - 43) x 10 = 120
WATER 1개를 판매해서 얻은 수익 : (20 - 23) x 1 = -3
따라서, 하루 동안의 총수익은 15 + 700 + 329 + 120 - 3 = 1161입니다.
재료 정보를 담은 문자열 배열 ings, 메뉴 정보를 담은 문자열 배열 menu, 하루 동안의 판매 실적을 담은 문자열 배열 sell이 매개변수로 주어집니다. 이때, 하루 동안의 총수익을 return 하도록 solution 함수를 완성해주세요.
총수익은 음수가 될 수도 있습니다. (입출력 예 #2 참고)

제한사항
1 ≤ ings의 길이 ≤ 26
ings의 각 원소는 "ING_NAME ING_PRICE" 형식입니다.
ING_NAME은 재료의 이름을 나타내며, 알파벳 소문자 하나로 표시됩니다.
ING_PRICE는 재료의 가격을 나타내는 정수입니다.
1 ≤ ING_PRICE ≤ 1000
ING_NAME과 ING_PRICE는 1개의 공백으로 구분되어 있습니다.
ings에서 ING_NAME은 중복되어 나타나지 않습니다.
1 ≤ menu의 길이 ≤ 100
menu의 각 원소는 "MENU_NAME ING_LIST MENU_PRICE" 형식입니다.
MENU_NAME은 식당에서 판매하고 있는 메뉴의 이름을 나타내며, 알파벳 대문자로 구성된 문자열입니다.
3 ≤ MENU_NAME의 길이 ≤ 10
ING_LIST는 메뉴를 만드는데 필요한 재료들을 나타내는, 알파벳 소문자로 구성된 문자열입니다.
1 ≤ ING_LIST의 길이 ≤ 20
ings에 담겨있는 재료들만 ING_LIST에 나타납니다.
MENU_PRICE는 메뉴의 가격을 나타내는 정수입니다.
1 ≤ MENU_PRICE ≤ 20000
MENU_NAME, ING_LIST, MENU_PRICE는 1개의 공백으로 구분되어 있습니다.
menu에서 MENU_NAME은 중복되어 나타나지 않습니다.
1 ≤ sell의 길이 ≤ menu의 길이 ≤ 100
sell의 각 원소는 "MENU_NAME SELL_COUNT" 형식입니다.
MENU_NAME은 판매된 메뉴의 이름을 나타내며, 알파벳 대문자로 구성된 문자열입니다.
3 ≤ MENU_NAME의 길이 ≤ 10
menu의 MENU_NAME으로 나타난 것들만 sell의 MENU_NAME에 나타납니다.
SELL_COUNT는 메뉴가 판매된 수량입니다.
1 ≤ SELL_COUNT ≤ 100
MENU_NAME과 SELL_COUNT는 1개의 공백으로 구분되어 있습니다.
sell에서 MENU_NAME은 중복되어 나타나지 않습니다.
입출력 예
ings	menu	sell	result
["r 10", "a 23", "t 124", "k 9"]	["PIZZA arraak 145", "HAMBURGER tkar 180", "BREAD kkk 30", "ICECREAM rar 50", "SHAVEDICE rar 45", "JUICE rra 55", "WATER a 20"]	["BREAD 5", "ICECREAM 100", "PIZZA 7", "JUICE 10", "WATER 1"]	1161
["x 25", "y 20", "z 1000"]	["AAAA xyxy 15", "TTT yy 30", "BBBB xx 30"]	["BBBB 3", "TTT 2"]	-80
입출력 예 설명
입출력 예 #1

문제 예시와 같습니다.

입출력 예 #2

재료의 정보

재료 이름	가격(원)
x	25
y	20
z	1000


메뉴의 정보

메뉴 이름	필요한 재료	판매가(원)
AAAA	xyxy	15
TTT	yy	30
BBBB	xx	30


하루 동안의 판매 실적

메뉴 이름	판매 수량
BBBB	3
TTT	2
BBBB 3개를 판매해서 얻은 수익 : (-20) x 3 = -60
TTT 2개를 판매해서 얻은 수익 : (-10) x 2 = -20
따라서, 하루 동안의 총수익은 (-60) + (-20) = -80입니다.


----

문제 설명
처음과 끝이 이어져 있는 문자열을 상상해봅시다. 당신은 해당 문자열 내의 "같은 글자가 연속해 있는" 구간들을 추출하고자 합니다.

문자열 s가 매개변수로 주어집니다. s 내의 모든 "같은 글자가 연속해 있는" 구간의 길이를 각각 배열에 담아 오름차순으로 정렬하여 return 하도록 solution 함수를 완성해주세요.

제한사항
3 ≤ s의 길이 ≤ 1,000
s는 영어 소문자로 이루어진 문자열입니다.
입출력 예
s	result
"aaabbaaa"	[2,6]
"wowwow"	[1,1,2,2]
입출력 예 설명
입출력 예 #1

다음 애니메이션은 처음과 끝이 이어진 "aaabbaaa"의 각 구간을 구하는 과정을 나타낸 것입니다.
ex1

각 구간의 길이는 6("aaaaaa"), 2("bb")이므로, 이를 정렬한 [2,6]을 return 해야 합니다.
입출력 예 #2

다음 애니메이션은 처음과 끝이 이어진 "wowwow"의 각 구간을 구하는 과정을 나타낸 것입니다.
ex2

각 구간의 길이는 2("ww"), 1("o"), 2("ww"), 1("o")이므로, 이를 정렬한 [1,1,2,2]를 return 해야 합니다.


----

문제 설명
rows행 columns열로 이루어진 격자가 있습니다. 처음에 모든 격자 칸 안에는 숫자 0이 쓰여 있습니다. 당신은 다음과 같은 과정을 통하여 격자에 숫자들을 채우고자 합니다.

현재 위치를 1행 1열로 정하고, 그 위치에 숫자 1을 씁니다.
r을 현재 위치의 행, c를 현재 위치의 열로 정의합니다.
만약 격자 내에 0이 쓰인 칸이 없거나, 더 이상 0이 쓰여 있는 칸에 다른 숫자를 쓸 수 없게 된다면 과정을 즉시 종료합니다.
만약 가장 최근에 쓴 숫자가 짝수라면, r행 c열에서 r+1행 c열로 이동합니다. r = rows라면, 1행으로 이동합니다.
만약 가장 최근에 쓴 숫자가 홀수라면, r행 c열에서 r행 c+1열로 이동합니다. c = columns라면, 1열로 이동합니다.
도착한 칸에 원래 쓰여 있던 수를 지우고 가장 최근에 쓴 숫자 + 1을 씁니다.
2번 과정으로 돌아갑니다.
정수 rows와 columns가 매개변수로 주어집니다. 주어진 과정을 따라 rows행 columns열로 이루어진 격자에 숫자를 썼을 때, 해당 격자를 2차원 정수 배열로 return 하도록 solution 함수를 완성해주세요.

제한사항
2 ≤ rows ≤ 1,000
2 ≤ columns ≤ 1,000
입출력 예
rows	columns	result
3	4	[[8,2,13,14],[16,10,4,15],[17,11,12,6]]
3	3	[[1,2,0],[0,3,4],[6,0,5]]
입출력 예 설명
입출력 예 #1

다음 애니메이션과 표는 숫자를 채우는 과정을 나타낸 것입니다.
ex1.png

숫자	위치	비고
1	1행 1열	가장 최근에 1(홀수)을 썼기 때문에, 열을 1 증가시킵니다.
2	1행 2열	가장 최근에 2(짝수)를 썼기 때문에, 행을 1 증가시킵니다.
3	2행 2열
4	2행 3열
5	3행 3열
6	3행 4열	기존의 위치가 3행이었기 때문에 1행으로 이동합니다.
7	1행 4열	기존의 위치가 4열이었기 때문에 1열로 이동합니다.
8	1행 1열	기존에 쓰여 있던 1을 지우고 8을 씁니다.
9	2행 1열
10	2행 2열
11	3행 2열
12	3행 3열
13	1행 3열
14	1행 4열
15	2행 4열
16	2행 1열
17	3행 1열	0이 쓰인 칸이 남지 않았으므로, 과정을 종료합니다.
입출력 예 #2

다음 애니메이션과 표는 숫자를 채우는 과정을 나타낸 것입니다.
ex2.png

숫자	위치	비고
1	1행 1열
2	1행 2열
3	2행 2열
4	2행 3열
5	3행 3열
6	3행 1열	이후부터는 같은 위치를 계속해서 빙글빙글 돌게 되므로, 더 이상 0이 쓰인 칸에 숫자를 쓸 수 없습니다. 따라서 과정을 종료합니다.


-----

문제 설명
해외 여행을 매우 좋아하는 준이 다니고 있는 대표적인 푸드테크 기업 W는 주 35시간 근무, 시간제 휴가로 유명한 회사입니다. 준은 회사의 출퇴근 시간을 잘 활용하여 해외 여행은 항상 금요일에 출발하여 다음 월요일에 돌아오도록 여행 일정을 세웁니다.

요일	출근 시간	퇴근 시간
월	1PM	6PM
금	9:30AM	6PM
올해 호치민을 마지막으로 다녀온 준은 남은 휴가 시간을 고려하지 않은 채 비행기 시간만 고려하여 여행 일정을 세웠습니다. 올해 남은 휴가 시간 time과 여행 일정을 담은 이차원 배열 plans가 매개변수로 주어질 때, 남은 휴가 시간 내에 갈 수 있는 여행지 중 준의 올해 마지막 여행지가 어디인지 return 하도록 solution 메서드를 완성해주세요.

제한사항
1 ≤ plans의 길이 ≤ 1,000
plans의 원소는 여행지, 출발 시간, 도착 시간 형식입니다.
여행 일정은 겹치지 않으며 계획 순서대로 이루어져 있습니다.
여행지는 길이가 1 이상 30 이하인 문자열입니다.
출발 시간과 도착 시간은 12시간제로 표기하며 길이가 3 이상 4 이하인 문자열입니다.
출발 시간과 도착 시간의 최소 단위는 1시간입니다.
출발 시간은 금요일이 기준이며, 도착 시간은 다음 월요일이 기준입니다.
오전은 "AM", 오후는 "PM"으로 표기합니다.
time의 0.5는 30분을 의미하며, time의 최소 단위는 30분입니다.
회사에서 공항까지 이동 시간, 점심시간은 고려하지 않습니다.
입출력 예
time	plans	result
3.5	[ ["홍콩", "11PM", "9AM"], ["엘에이", "3PM", "2PM"] ]	"홍콩"
입출력 예 설명
입출력 예 1
올해 남은 휴가 시간은 3.5시간입니다. 엘에이까지 다녀오려면 4시간의 휴가가 필요해서 30분이 부족합니다. 따라서 마지막 여행지는 홍콩입니다.


-----


문제 설명
한 변의 길이가 1인 정삼각형 n2 개로 구성된 정삼각형 격자가 있습니다. 격자의 각 칸에는 문자(영어 대소문자 또는 숫자) 하나가 쓰여 있습니다. 당신은 이 격자를 시계 방향 또는 반시계 방향으로 120도 회전하고자 합니다.

격자의 정보를 나타내는 문자열 배열 grid와 회전 방향을 나타내는 clockwise가 매개변수로 주어집니다. 주어진 격자를 clockwise가 의미하는 방향으로 회전시킨 결과를 배열에 담아 return 하도록 solution 함수를 완성해주세요.

제한사항
1 ≤ grid의 길이 ≤ 1,000
grid[i]의 길이 = 2 * i + 1
grid[i]는 영어 대소문자 또는 숫자로 이루어진 문자열입니다.
clockwise가 참이면 시계 방향, 거짓이면 반시계 방향으로 120도 회전해야 함을 의미합니다.
입출력 예
grid	clockwise	result
["1","234","56789"]	true	["5","762","98431"]
["A","MAN","DRINK","WATER11"]	false	["1","K1R","NNIET","AAMRDAW"]
입출력 예 설명
입출력 예 #1

다음 애니메이션은 주어진 격자를 시계 방향으로 회전하는 것을 나타낸 것입니다.
ex1

따라서, ["5","762","98431"]를 return 해야 합니다.
입출력 예 #2

다음 애니메이션은 주어진 격자를 반시계 방향으로 회전하는 것을 나타낸 것입니다.
ex2

따라서, ["1","K1R","NNIET","AAMRDAW"]를 return 해야 합니다